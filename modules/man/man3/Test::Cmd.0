.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Test::Cmd 3"
.TH Test::Cmd 3 "2015-10-25" "perl v5.24.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Cmd \- Perl module for portable testing of commands and scripts
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
An example using Test::More with this module to run a command
and then test the exit code, standard out, and standard error:
.PP
.Vb 2
\&  use Test::Cmd;
\&  use Test::More tests => 3;
\&
\&  my $test = Test::Cmd\->new( prog => \*(Aqouterr\*(Aq, workdir => \*(Aq\*(Aq );
\&  $test\->run();
\&
\&  is( $test\->stdout, "out\en", \*(Aqstandard out\*(Aq );
\&  is( $test\->stderr, "err\en", \*(Aqstandard error\*(Aq );
\&  is( $? >> 8,       1,       \*(Aqexit status\*(Aq );
.Ve
.PP
Where \f(CW\*(C`outerr\*(C'\fR is the shell script:
.PP
.Vb 6
\&  $ cat outerr 
\&  #!/bin/sh
\&  echo out
\&  echo >&2 err
\&  exit 1
\&  $ chmod +x outerr
.Ve
.PP
See below for other examples. Otherwise, the full list of available
methods is:
.PP
.Vb 1
\&  use Test::Cmd;
\&
\&  $test = Test::Cmd\->new(prog => \*(Aqprogram_or_script_to_test\*(Aq,
\&                        interpreter => \*(Aqscript_interpreter\*(Aq,
\&                        string => \*(Aqidentifier_string\*(Aq,
\&                        workdir => \*(Aq\*(Aq,
\&                        subdir => \*(Aqdir\*(Aq,
\&                        match_sub => $code_ref,
\&                        verbose => 1);
\&
\&  $test\->verbose(1);
\&
\&  $test\->prog(\*(Aqprogram_or_script_to_test\*(Aq);
\&
\&  $test\->basename(@suffixlist);
\&
\&  $test\->interpreter(\*(Aqscript_interpreter\*(Aq);
\&
\&  $test\->string(\*(Aqidentifier string\*(Aq);
\&
\&  $test\->workdir(\*(Aqprefix\*(Aq);
\&
\&  $test\->workpath(\*(Aqsubdir\*(Aq, \*(Aqfile\*(Aq);
\&
\&  $test\->subdir(\*(Aqsubdir\*(Aq, ...);
\&  $test\->subdir([\*(Aqsub\*(Aq, \*(Aqdir\*(Aq], ...);
\&
\&  $test\->write(\*(Aqfile\*(Aq, <<\*(AqEOF\*(Aq);
\&  contents of file
\&  EOF
\&  $test\->write([\*(Aqsubdir\*(Aq, \*(Aqfile\*(Aq], <<\*(AqEOF\*(Aq);
\&  contents of file
\&  EOF
\&
\&  $test\->read(\e$contents, \*(Aqfile\*(Aq);
\&  $test\->read(\e@lines, \*(Aqfile\*(Aq);
\&  $test\->read(\e$contents, [\*(Aqsubdir\*(Aq, \*(Aqfile\*(Aq]);
\&  $test\->read(\e@lines, [\*(Aqsubdir\*(Aq, \*(Aqfile\*(Aq]);
\&
\&  $test\->writable(\*(Aqdir\*(Aq);
\&  $test\->writable(\*(Aqdir\*(Aq, $rwflag);
\&  $test\->writable(\*(Aqdir\*(Aq, $rwflag, \e%errors);
\&
\&  $test\->preserve(condition, ...);
\&
\&  $test\->cleanup(condition);
\&
\&  $test\->run(prog => \*(Aqprogram_or_script_to_test\*(Aq,
\&                interpreter => \*(Aqscript_interpreter\*(Aq,
\&                chdir => \*(Aqdir\*(Aq, args => \*(Aqarguments\*(Aq, stdin => <<\*(AqEOF\*(Aq);
\&  input to program
\&  EOF
\&
\&  $test\->pass(condition);
\&  $test\->pass(condition, \e&func);
\&
\&  $test\->fail(condition);
\&  $test\->fail(condition, \e&func);
\&  $test\->fail(condition, \e&func, $caller);
\&
\&  $test\->no_result(condition);
\&  $test\->no_result(condition, \e&func);
\&  $test\->no_result(condition, \e&func, $caller);
\&
\&  $test\->stdout;
\&  $test\->stdout($run_number);
\&
\&  $test\->stderr;
\&  $test\->stderr($run_number);
\&
\&  $test\->match(\e@lines, \e@matches);
\&  $test\->match($lines, $matches);
\&
\&  $test\->match_exact(\e@lines, \e@matches);
\&  $test\->match_exact($lines, $matches);
\&
\&  $test\->match_regex(\e@lines, \e@regexes);
\&  $test\->match_regex($lines, $regexes);
\&
\&  $test\->diff_exact(\e@lines, \e@matches, \e@output);
\&  $test\->diff_exact($lines, $matches, \e@output);
\&
\&  $test\->diff_regex(\e@lines, \e@regexes, \e@output);
\&  $test\->diff_regex($lines, $regexes, \e@output);
\&
\&  sub func {
\&        my ($self, $lines, $matches) = @_;
\&        # code to match $lines and $matches
\&  }
\&  $test\->match_sub(\e&func);
\&  $test\->match_sub(sub { code to match $_[1] and $_[2] });
\&
\&  $test\->here;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Test::Cmd\*(C'\fR module provides a low-level framework for portable
automated testing of executable commands and scripts (in any language,
not just Perl), especially commands and scripts that interact with the
file system.
.PP
The \f(CW\*(C`Test::Cmd\*(C'\fR module makes no assumptions about what constitutes
a successful or failed test.  Attempting to read a file that doesn't
exist, for example, may or may not be an error, depending on the
software being tested.
.PP
Consequently, no \f(CW\*(C`Test::Cmd\*(C'\fR methods (including the \f(CW\*(C`new()\*(C'\fR method)
exit, die or throw any other sorts of exceptions (but they all do return
useful error indications).  Exceptions or other error status should
be handled by a higher layer: a subclass of Test::Cmd, or another
testing framework such as the Test or Test::Simple Perl modules,
or by the test itself.
.PP
(That said, see the Test::Cmd::Common module if you want a similar
module that provides exception handling, either to use directly in your
own tests, or as an example of how to use \f(CW\*(C`Test::Cmd\*(C'\fR.)
.PP
In addition to running tests and evaluating conditions, the \f(CW\*(C`Test::Cmd\*(C'\fR
module manages and cleans up one or more temporary workspace
directories, and provides methods for creating files and directories in
those workspace directories from in-line data (that is, here-documents),
allowing tests to be completely self-contained.  When used in
conjunction with another testing framework, the \f(CW\*(C`Test::Cmd\*(C'\fR module can
function as a \fIfixture\fR (common startup code for multiple tests) for
simple management of command execution and temporary workspaces.
.PP
The \f(CW\*(C`Test::Cmd\*(C'\fR module inherits File::Spec methods
(\f(CW\*(C`file_name_is_absolute()\*(C'\fR, \f(CW\*(C`catfile()\*(C'\fR, etc.) to support writing
tests portably across a variety of operating and file systems.
.PP
A \f(CW\*(C`Test::Cmd\*(C'\fR environment object is created via the usual invocation:
.PP
.Vb 1
\&    $test = Test::Cmd\->new();
.Ve
.PP
Arguments to the \f(CW\*(C`Test::Cmd::new\*(C'\fR method are keyword-value pairs that
may be used to initialize the object, typically by invoking the same-named
method as the keyword.
.SH "TESTING FRAMEWORKS"
.IX Header "TESTING FRAMEWORKS"
As mentioned, because the \f(CW\*(C`Test::Cmd\*(C'\fR module makes no assumptions
about what constitutes success or failure of a test, it can be used to
provide temporary workspaces, other file system interaction, or command
execution for a variety of testing frameworks.  This section describes
how to use the \f(CW\*(C`Test::Cmd\*(C'\fR with several different higher-layer testing
frameworks.
.PP
Note that you should \fInot\fR intermix multiple testing frameworks in a
single testing script.
.ie n .SS """Test::Harness"""
.el .SS "\f(CWTest::Harness\fP"
.IX Subsection "Test::Harness"
The \f(CW\*(C`Test::Cmd\*(C'\fR module may be used in tests that print results in a
format suitable for the standard Perl Test::Harness module:
.PP
.Vb 1
\&    use Test::Cmd;
\&
\&    print "1..5\en";
\&
\&    $test = Test::Cmd\->new(prog => \*(Aqtest_program\*(Aq, workdir => \*(Aq\*(Aq);
\&    if ($test) { print "ok 1\en"; } else { print "not ok 1\en"; }
\&
\&    $input = <<_EOF;
\&    test_program should process this input
\&    and exit successfully (status 0).
\&    _EOF_
\&
\&    $wrote_file = $test\->write(\*(Aqinput_file\*(Aq, $input);
\&    if ($wrote_file) { print "ok 2\en"; } else { print "not ok 2\en"; }
\&
\&    $test\->run(args => \*(Aq\-x input_file\*(Aq);
\&    if ($? == 0) { print "ok 3\en"; } else { print "not ok 3\en"; }
\&
\&    $wrote_file = $test\->write(\*(Aqinput_file\*(Aq, $input);
\&    if ($wrote_file) { print "ok 4\en"; } else { print "not ok 4\en"; }
\&
\&    $test\->run(args => \*(Aq\-y input_file\*(Aq);
\&    if ($? == 0) { print "ok 5\en"; } else { print "not ok 5\en"; }
.Ve
.PP
Several other Perl modules simplify the use of Test::Harness
by eliminating the need to hand-code the \f(CW\*(C`print\*(C'\fR statements and
test numbers.  The Test module, the Test::Simple module, and
the Test::More module all export an \f(CW\*(C`ok()\*(C'\fR subroutine to test
conditions.  Here is how the above example would look rewritten to use
Test::Simple:
.PP
.Vb 2
\&    use Test::Simple tests => 5;
\&    use Test::Cmd;
\&
\&    $test = Test::Cmd\->new(prog => \*(Aqtest_program\*(Aq, workdir => \*(Aq\*(Aq);
\&    ok($test, "creating Test::Cmd object");
\&
\&    $input = <<_EOF;
\&    test_program should process this input
\&    and exit successfully (status 0).
\&    _EOF_
\&
\&    $wrote_file = $test\->write(\*(Aqinput_file\*(Aq, $input);
\&    ok($wrote_file, "writing input_file");
\&
\&    $test\->run(args => \*(Aq\-x input_file\*(Aq);
\&    ok($? == 0, "executing test_program \-x input_file");
\&
\&    $wrote_file = $test\->write(\*(Aqinput_file\*(Aq, $input);
\&    ok($wrote_file, "writing input_file");
\&
\&    $test\->run(args => \*(Aq\-y input_file\*(Aq);
\&    ok($? == 0, "executing test_program \-y input_file");
.Ve
.ie n .SS """Test::Unit"""
.el .SS "\f(CWTest::Unit\fP"
.IX Subsection "Test::Unit"
The Perl Test::Unit package provides a procedural testing interface
modeled after a testing framework widely used in the eXtreme Programming
development methodology.  The \f(CW\*(C`Test::Cmd\*(C'\fR module can function as part
of a Test::Unit fixture that can set up workspaces as needed for a
set of tests.  This avoids having to repeat code to re-initialize an
input file multiple times:
.PP
.Vb 2
\&    use Test::Unit;
\&    use Test::Cmd;
\&    
\&    my $test;
\&    
\&    $input = <<\*(AqEOF\*(Aq;
\&    test_program should process this input
\&    and exit successfully (status 0).
\&    EOF
\&    
\&    sub set_up {
\&        $test = Test::Cmd\->new(prog => \*(Aqtest_program\*(Aq, workdir => \*(Aq\*(Aq);
\&        $test\->write(\*(Aqinput_file\*(Aq, $input);
\&    }
\&    
\&    sub test_x {
\&        my $result = $test\->run(args => \*(Aq\-x input_file\*(Aq);
\&        assert($result == 0, "failed test_x\en");
\&    }
\&    
\&    sub test_y {
\&        my $result = $test\->run(args => \*(Aq\-y input_file\*(Aq);
\&        assert($result == 0, "failed test_y\en");
\&    }
\&    
\&    create_suite();
\&    run_suite;
.Ve
.PP
Note that, because the \f(CW\*(C`Test::Cmd\*(C'\fR module takes care of cleaning up
temporary workspaces on exit, there is no need to remove explicitly the
workspace in a \f(CW\*(C`tear_down\*(C'\fR subroutine.  (There may, of course, be other
things in the test that need a \f(CW\*(C`tear_down\*(C'\fR subroutine.)
.SS "Aegis"
.IX Subsection "Aegis"
Alternatively, the \f(CW\*(C`Test::Cmd\*(C'\fR module provides \f(CW\*(C`pass()\*(C'\fR, \f(CW\*(C`fail()\*(C'\fR,
and \f(CW\*(C`no_result()\*(C'\fR methods that can be used to provide an appropriate
exit status and simple printed indication for a test.  These methods
terminate the test immediately, reporting \f(CW\*(C`PASSED\*(C'\fR, \f(CW\*(C`FAILED\*(C'\fR, or
\&\f(CW\*(C`NO RESULT\*(C'\fR respectively, and exiting with status 0 (success), 1 or 2
respectively.
.PP
The separate \f(CW\*(C`fail()\*(C'\fR and \f(CW\*(C`no_result()\*(C'\fR methods allow for a
distinction between an actual failed test and a test that could not be
properly evaluated because of an external condition (such as a full file
system or incorrect permissions).
.PP
The exit status values happen to match the requirements of the Aegis
change management system, and the printed strings are based on existing
Aegis conventions.  They are not really Aegis-specific, however, and
provide a simple, useful starting point if you don't already have
another testing framework:
.PP
.Vb 1
\&    use Test::Cmd;
\&
\&    $test = Test::Cmd\->new(prog => \*(Aqtest_program\*(Aq, workdir => \*(Aq\*(Aq);
\&    Test::Cmd\->no_result(! $test);
\&
\&    $input = <<EOF;
\&    test_program should process this input
\&    and exit successfully (status 0).
\&    EOF
\&
\&    $wrote_file = $test\->write(\*(Aqinput_file\*(Aq, $input);
\&    $test\->no_result(! $wrote_file);
\&
\&    $test\->run(args => \*(Aq\-x input_file\*(Aq);
\&    $test\->fail($? != 0);
\&
\&    $wrote_file = $test\->write(\*(Aqinput_file\*(Aq, $input);
\&    $test\->no_result(! $wrote_file);
\&
\&    $test\->run(args => \*(Aq\-y input_file\*(Aq);
\&    $test\->fail($? != 0);
\&
\&    $test\->pass;
.Ve
.PP
Note that the separate Test::Cmd::Common wrapper module can simplify
the above example even further by taking care of common exception
handling cases within the testing object itself.
.PP
.Vb 1
\&    use Test::Cmd::Common;
\&
\&    $test = Test::Cmd::Common\->new(prog => \*(Aqtest_program\*(Aq, workdir => \*(Aq\*(Aq);
\&
\&    $input = <<EOF;
\&    test_program should process this input
\&    and exit successfully (status 0).
\&    EOF
\&
\&    $wrote_file = $test\->write(\*(Aqinput_file\*(Aq, $input);
\&
\&    $test\->run(args => \*(Aq\-x input_file\*(Aq);
\&
\&    $wrote_file = $test\->write(\*(Aqinput_file\*(Aq, $input);
\&
\&    $test\->run(args => \*(Aq\-y input_file\*(Aq);
\&
\&    $test\->pass;
.Ve
.PP
See the Test::Cmd::Common module for details.
.SH "METHODS"
.IX Header "METHODS"
Methods supported by the \f(CW\*(C`Test::Cmd\*(C'\fR module include:
.ie n .IP """new""" 4
.el .IP "\f(CWnew\fR" 4
.IX Item "new"
Create a new \f(CW\*(C`Test::Cmd\*(C'\fR environment.  Arguments with which to initialize
the environment are passed in as keyword-value pairs.  Fails if a
specified temporary working directory or subdirectory cannot be created.
Does \s-1NOT\s0 die or exit on failure, but returns \f(CW\*(C`undef\*(C'\fR if the test environment
object cannot be created.
.ie n .IP """verbose""" 4
.el .IP "\f(CWverbose\fR" 4
.IX Item "verbose"
Sets the verbose level for the environment object to the specified value.
.ie n .IP """prog""" 4
.el .IP "\f(CWprog\fR" 4
.IX Item "prog"
Specifies the executable program or script to be tested.  Returns the
absolute path name of the current program or script.
.ie n .IP """basename""" 4
.el .IP "\f(CWbasename\fR" 4
.IX Item "basename"
Returns the basename of the current program or script.  Any specified
arguments are a list of file suffixes that may be stripped from the
basename.
.ie n .IP """interpreter""" 4
.el .IP "\f(CWinterpreter\fR" 4
.IX Item "interpreter"
Specifies the program to be used to interpret \f(CW\*(C`prog\*(C'\fR as a script.
Returns the current value of \f(CW\*(C`interpreter\*(C'\fR.
.ie n .IP """string""" 4
.el .IP "\f(CWstring\fR" 4
.IX Item "string"
Specifies an identifier string for the functionality being tested to be
printed on failure or no result.
.ie n .IP """workdir""" 4
.el .IP "\f(CWworkdir\fR" 4
.IX Item "workdir"
When an argument is specified, creates a temporary working directory
with the specified name.  If the argument is a \s-1NULL\s0 string (''),
the directory is named \f(CW\*(C`testcmd\*(C'\fR by default, followed by the
unique \s-1ID\s0 of the executing process.
.Sp
Returns the absolute pathname to the temporary working directory, or
\&\s-1FALSE\s0 if the directory could not be created.
.ie n .IP """workpath""" 4
.el .IP "\f(CWworkpath\fR" 4
.IX Item "workpath"
Returns the absolute path name to a subdirectory or file under the
current temporary working directory by concatenating the temporary
working directory name with the specified arguments.
.ie n .IP """subdir""" 4
.el .IP "\f(CWsubdir\fR" 4
.IX Item "subdir"
Creates new subdirectories under the temporary working dir, one for
each argument.  An argument may be an array reference, in which case the
array elements are concatenated together using the \f(CW\*(C`File::Spec\-&\*(C'\fRcatfile>
method.  Subdirectories multiple levels deep must be created via a
separate argument for each level:
.Sp
.Vb 1
\&    $test\->subdir(\*(Aqsub\*(Aq, [\*(Aqsub\*(Aq, \*(Aqdir\*(Aq], [qw(sub dir ectory)]);
.Ve
.Sp
Returns the number of subdirectories actually created.
.ie n .IP """write""" 4
.el .IP "\f(CWwrite\fR" 4
.IX Item "write"
Writes the specified text (second argument) to the specified file name
(first argument).  The file name may be an array reference, in which
case all the array elements except the last are subdirectory names
to be concatenated together.  The file is created under the temporary
working directory.  Any subdirectories in the path must already exist.
.ie n .IP """read""" 4
.el .IP "\f(CWread\fR" 4
.IX Item "read"
Reads the contents of the specified file name (second argument) into
the scalar or array referred to by the first argument.  The file name
may be an array reference, in which case all the array elements except
the last are subdirectory names to be concatenated together.  The file
is assumed to be under the temporary working directory unless it is an
absolute path name.
.Sp
Returns \s-1TRUE\s0 on successfully opening and reading the file, \s-1FALSE\s0
otherwise.
.ie n .IP """writable""" 4
.el .IP "\f(CWwritable\fR" 4
.IX Item "writable"
Makes every file and directory within the specified directory tree
writable (\f(CW\*(C`rwflag\*(C'\fR == \s-1TRUE\s0) or not writable (\f(CW\*(C`rwflag\*(C'\fR == \s-1FALSE\s0).  The
default is to make the directory tree writable.  Optionally fills in the
supplied hash reference with a hash of path names that could not have
their permissions set appropriately, with the reason why each could not
be set.
.ie n .IP """preserve""" 4
.el .IP "\f(CWpreserve\fR" 4
.IX Item "preserve"
Arranges for the temporary working directories for the specified
\&\f(CW\*(C`Test::Cmd\*(C'\fR environment to be preserved for one or more conditions.
If no conditions are specified, arranges for the temporary working
directories to be preserved for all conditions.
.ie n .IP """cleanup""" 4
.el .IP "\f(CWcleanup\fR" 4
.IX Item "cleanup"
Removes any temporary working directories for the specified \f(CW\*(C`Test::Cmd\*(C'\fR
environment.  If the environment variable \f(CW\*(C`PRESERVE\*(C'\fR was set when
the \f(CW\*(C`Test::Cmd\*(C'\fR module was loaded, temporary working directories are
not removed.  If any of the environment variables \f(CW\*(C`PRESERVE_PASS\*(C'\fR,
\&\f(CW\*(C`PRESERVE_FAIL\*(C'\fR, or \f(CW\*(C`PRESERVE_NO_RESULT\*(C'\fR were set when the \f(CW\*(C`Test::Cmd\*(C'\fR
module was loaded, then temporary working directories are not removed
if the test passed, failed, or had no result, respectively.  Temporary
working directories are also preserved for conditions specified via the
\&\f(CW\*(C`preserve\*(C'\fR method.
.Sp
Typically, this method is not called directly, but is used when the
script exits to clean up temporary working directories as appropriate
for the exit status.
.ie n .IP """run""" 4
.el .IP "\f(CWrun\fR" 4
.IX Item "run"
Runs a test of the program or script for the test environment.  Standard
output and error output are saved for future retrieval via the \f(CW\*(C`stdout\*(C'\fR
and \f(CW\*(C`stderr\*(C'\fR methods.
.Sp
Arguments are supplied as keyword-value pairs:
.RS 4
.ie n .IP """args""" 4
.el .IP "\f(CWargs\fR" 4
.IX Item "args"
Specifies the command-line arguments to be supplied to the program
or script under test for this run:
.Sp
.Vb 1
\&        $test\->run(args => \*(Aqarg1 arg2\*(Aq);
.Ve
.ie n .IP """chdir""" 4
.el .IP "\f(CWchdir\fR" 4
.IX Item "chdir"
Changes directory to the path specified as the value argument:
.Sp
.Vb 1
\&        $test\->run(chdir => \*(Aqxyzzy\*(Aq);
.Ve
.Sp
If the specified path is not an absolute path name (begins with '/'
on Unix systems), then the subdirectory is relative to the temporary
working directory for the environment (\f(CW\*(C`$test\-&\*(C'\fRworkdir>).  Note that,
by default, the \f(CW\*(C`Test::Cmd\*(C'\fR module does \s-1NOT\s0 chdir to the temporary
working directory, so to execute the test under the temporary working
directory, you must specify an explicit \f(CW\*(C`chdir\*(C'\fR to the current directory:
.Sp
.Vb 1
\&        $test\->run(chdir => \*(Aq.\*(Aq);               # Unix\-specific
\&
\&        $test\->run(chdir => $test\->curdir);     # portable
.Ve
.ie n .IP """interpreter""" 4
.el .IP "\f(CWinterpreter\fR" 4
.IX Item "interpreter"
Specifies the program to be used to interpret \f(CW\*(C`prog\*(C'\fR as a script,
for this run only.  This does not change the \f(CW\*(C`$test\-&\*(C'\fRinterpreter>
value of the test environment.
.ie n .IP """prog""" 4
.el .IP "\f(CWprog\fR" 4
.IX Item "prog"
Specifies the executable program or script to be run, for this run only.
This does not change the \f(CW\*(C`$test\-&\*(C'\fRprog> value of the test environment.
.ie n .IP """stdin""" 4
.el .IP "\f(CWstdin\fR" 4
.IX Item "stdin"
Pipes the specified value (string or array ref) to the program
or script under test for this run:
.Sp
.Vb 3
\&        $test\->run(stdin => <<_EOF_);
\&        input to the program under test
\&        _EOF_
.Ve
.RE
.RS 4
.Sp
Returns the exit status of the program or script.
.RE
.ie n .IP """pass""" 4
.el .IP "\f(CWpass\fR" 4
.IX Item "pass"
Exits the test successfully.  Reports \*(L"\s-1PASSED\*(R"\s0 on the error output and
exits with a status of 0.  If a condition is supplied, only exits
the test if the condition evaluates \s-1TRUE. \s0 If a function reference is
supplied, executes the function before reporting and exiting.
.ie n .IP """fail""" 4
.el .IP "\f(CWfail\fR" 4
.IX Item "fail"
Exits the test unsuccessfully.  Reports \*(L"\s-1FAILED\s0 test of {string} at line
{line} of {file}.\*(R" on the error output and exits with a status of 1.
If a condition is supplied, only exits the test if the condition evaluates
\&\s-1TRUE. \s0 If a function reference is supplied, executes the function before
reporting and exiting.  If a caller level is supplied, prints a simple
calling trace N levels deep as part of reporting the failure.
.ie n .IP """no_result""" 4
.el .IP "\f(CWno_result\fR" 4
.IX Item "no_result"
Exits the test with an indeterminate result (the test could not be
performed due to external conditions such as, for example, a full
file system).  Reports \*(L"\s-1NO RESULT\s0 for test of {string} at line {line} of
{file}.\*(R" on the error output and exits with a status of 2.  If a condition
is supplied, only exits the test if the condition evaluates \s-1TRUE. \s0 If a
function reference is supplied, executes the function before reporting
and exiting.  If a caller level is supplied, prints a simple calling
trace N levels deep as part of reporting the failure.
.ie n .IP """stdout""" 4
.el .IP "\f(CWstdout\fR" 4
.IX Item "stdout"
Returns the standard output from the specified run number.  If there is no
specified run number, then returns the standard output of the last run.
Returns the standard output as either a scalar or an array of output
lines, as appropriate for the calling context.  Returns \f(CW\*(C`undef\*(C'\fR if
there has been no test run.
.ie n .IP """stderr""" 4
.el .IP "\f(CWstderr\fR" 4
.IX Item "stderr"
Returns the error output from the specified run number.  If there is
no specified run number, then returns the error output of the last run.
Returns the error output as either a scalar or an array of output lines,
as apporpriate for the calling context.  Returns \f(CW\*(C`undef\*(C'\fR if there has
been no test run.
.ie n .IP """match""" 4
.el .IP "\f(CWmatch\fR" 4
.IX Item "match"
Matches one or more input lines against an equal number of expected lines
using the currently-registered line-matching function.  The default
line-matching function is the \f(CW\*(C`match_regex\*(C'\fR method, which means that
the default is to match lines against regular expressions.
.ie n .IP """match_exact""" 4
.el .IP "\f(CWmatch_exact\fR" 4
.IX Item "match_exact"
Compares two arrays of lines for exact matches.  The arguments are passed
in as either scalars, in which case each is split on newline boundaries,
or as array references.  An unequal number of lines in the two arrays
fails immediately and returns \s-1FALSE\s0 before any comparisons are performed.
.Sp
Returns \s-1TRUE\s0 if each line matched its corresponding line in the other
array, \s-1FALSE\s0 otherwise.
.ie n .IP """match_regex""" 4
.el .IP "\f(CWmatch_regex\fR" 4
.IX Item "match_regex"
Matches one or more input lines against an equal number of regular
expressions.  The arguments are passed in as either scalars, in which
case each is split on newline boundaries, or as array references.
Trailing newlines are stripped from each line and regular expression.
An unequal number of lines and regular expressions fails immediately
and returns \s-1FALSE\s0 before any comparisons are performed.  Comparison is
performed for each entire line, that is, with each regular expression
anchored at both the start of line (^) and end of line ($).
.Sp
Returns \s-1TRUE\s0 if each line matched each regular expression, \s-1FALSE\s0
otherwise.
.ie n .IP """diff_exact""" 4
.el .IP "\f(CWdiff_exact\fR" 4
.IX Item "diff_exact"
Diffs two arrays of lines in a manner similar to the \s-1UNIX \s0\fIdiff\fR\|(1)
utility.
.Sp
If the Algorithm::DiffOld package is installed on the local system,
output describing the differences between the input lines and the
matching lines, in \fIdiff\fR\|(1) format, is saved to the \f(CW$output\fR array
reference.  In the diff output, the expected output lines are considered
the \*(L"old\*(R" (left-hand) file, and the actual output is considered the
\&\*(L"new\*(R" (right-hand) file.
.Sp
If the Algorithm::DiffOld package is \fInot\fR installed on the local
system, the Expected and Actual contents are saved as-is to the
\&\f(CW$output\fR array reference.
.Sp
The \f(CW\*(C`lines\*(C'\fR and \f(CW\*(C`matches\*(C'\fR arguments are passed in as either scalars,
in which case each is split on newline boundaries, or as array
references.  Trailing newlines are stripped from each line and regular
expression.
.Sp
Returns \s-1TRUE\s0 if each line matched its corresponding line in the expected
matches, \s-1FALSE\s0 otherwise, in order to conform to the conventions of the
\&\f(CW\*(C`match\*(C'\fR method.
.Sp
Typical invocation:
.Sp
.Vb 5
\&        if (! $test\->diff_exact($test\->stdout,
\&                                \e@expected_lines,
\&                                \e@diff)) {
\&                print @diff;
\&        }
.Ve
.ie n .IP """diff_regex""" 4
.el .IP "\f(CWdiff_regex\fR" 4
.IX Item "diff_regex"
Diffs one or more input lines against one or more regular expressions
in a manner similar to the \s-1UNIX \s0\fIdiff\fR\|(1) utility.
.Sp
If the Algorithm::DiffOld package is installed on the local system,
output describing the differences between the input lines and the
matching lines, in \fIdiff\fR\|(1) format, is saved to the \f(CW$output\fR array
reference.  In the diff output, the expected output lines are considered
the \*(L"old\*(R" (left-hand) file, and the actual output is considered the
\&\*(L"new\*(R" (right-hand) file.
.Sp
If the Algorithm::DiffOld package is \fInot\fR installed on the local
system, the Expected and Actual contents are saved as-is to the
\&\f(CW$output\fR array reference.
.Sp
The \f(CW\*(C`lines\*(C'\fR and \f(CW\*(C`regexes\*(C'\fR arguments are passed in as either scalars,
in which case each is split on newline boundaries, or as array
references.  Trailing newlines are stripped from each line and regular
expression.  Comparison is performed for each entire line, that is, with
each regular expression anchored at both the start of line (^) and end
of line ($).
.Sp
Returns \s-1TRUE\s0 if each line matched each regular expression, \s-1FALSE\s0
otherwise, in order to conform to the conventions of the \f(CW\*(C`match\*(C'\fR
method.
.Sp
Typical invocation:
.Sp
.Vb 5
\&        if (! $test\->diff_regex($test\->stdout,
\&                                \e@expected_lines,
\&                                \e@diff)) {
\&                print @diff;
\&        }
.Ve
.ie n .IP """match_sub""" 4
.el .IP "\f(CWmatch_sub\fR" 4
.IX Item "match_sub"
Registers the specified code reference as the line-matching function
to be called by the \f(CW\*(C`match\*(C'\fR method.  This can be a user-supplied
subroutine, or the \f(CW\*(C`match_exact\*(C'\fR, \f(CW\*(C`match_regex\*(C'\fR, \f(CW\*(C`diff_exact\*(C'\fR, or
\&\f(CW\*(C`diff_regex\*(C'\fR methods supplied by the \f(CW\*(C`Test::Cmd\*(C'\fR module:
.Sp
.Vb 1
\&        $test\->match_sub(\e&Test::Cmd::match_exact);
\&
\&        $test\->match_sub(\e&Test::Cmd::match_regex);
\&
\&        $test\->match_sub(\e&Test::Cmd::diff_exact);
\&
\&        $test\->match_sub(\e&Test::Cmd::diff_regex);
.Ve
.Sp
The \f(CW\*(C`match_exact\*(C'\fR, \f(CW\*(C`match_regex\*(C'\fR, \f(CW\*(C`diff_exact\*(C'\fR and \f(CW\*(C`diff_regex\*(C'\fR
subroutine names are exportable from the \f(CW\*(C`Test::Cmd\*(C'\fR module, and may be
specified at object initialization:
.Sp
.Vb 5
\&        use Test::Cmd qw(match_exact match_regex diff_exact diff_regex);
\&        $test_exact = Test::Cmd\->new(match_sub => \e&match_exact);
\&        $test_regex = Test::Cmd\->new(match_sub => \e&match_regex);
\&        $test_exact = Test::Cmd\->new(match_sub => \e&diff_exact);
\&        $test_regex = Test::Cmd\->new(match_sub => \e&diff_regex);
.Ve
.ie n .IP """here""" 4
.el .IP "\f(CWhere\fR" 4
.IX Item "here"
Returns the absolute path name of the current working directory.
(This is essentially the same as the \f(CW\*(C`Cwd::cwd\*(C'\fR method, except that the
\&\f(CW\*(C`Test::Cmd::here\*(C'\fR method preserves the directory separators exactly
as returned by the underlying operating-system-dependent method.
The \f(CW\*(C`Cwd::cwd\*(C'\fR method canonicalizes all directory separators to '/',
which makes for consistent path name representations within Perl, but may
mess up another program or script to which you try to pass the path name.)
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
Several environment variables affect the default values in a newly created
\&\f(CW\*(C`Test::Cmd\*(C'\fR environment object.  These environment variables must be set
when the module is loaded, not when the object is created.
.ie n .IP """PRESERVE""" 4
.el .IP "\f(CWPRESERVE\fR" 4
.IX Item "PRESERVE"
If set to a true value, all temporary working directories will
be preserved on exit, regardless of success or failure of the test.
The full path names of all temporary working directories will be reported
on error output.
.ie n .IP """PRESERVE_FAIL""" 4
.el .IP "\f(CWPRESERVE_FAIL\fR" 4
.IX Item "PRESERVE_FAIL"
If set to a true value, all temporary working directories will be
preserved on exit from a failed test.  The full path names of all
temporary working directories will be reported on error output.
.ie n .IP """PRESERVE_NO_RESULT""" 4
.el .IP "\f(CWPRESERVE_NO_RESULT\fR" 4
.IX Item "PRESERVE_NO_RESULT"
If set to a true value, all temporary working directories will be
preserved on exit from a test for which there is no result.  The full
path names of all temporary working directories will be reported on
error output.
.ie n .IP """PRESERVE_PASS""" 4
.el .IP "\f(CWPRESERVE_PASS\fR" 4
.IX Item "PRESERVE_PASS"
If set to a true value, all temporary working directories will be
preserved on exit from a successful test.  The full path names of all
temporary working directories will be reported on error output.
.ie n .IP """VERBOSE""" 4
.el .IP "\f(CWVERBOSE\fR" 4
.IX Item "VERBOSE"
When set to a true value, enables verbose reporting of various internal
things (path names, exact command line being executed, etc.).
.SH "PORTABLE TESTS"
.IX Header "PORTABLE TESTS"
Although the \f(CW\*(C`Test::Cmd\*(C'\fR module is intended to make it easier to write
portable tests for portable utilities that interact with file systems,
it is still very easy to write non-portable tests if you're not careful.
.PP
The best and most comprehensive set of portability guidelines is the
standard \*(L"Writing portable Perl\*(R" document at:
.PP
.Vb 1
\&        http://www.perl.com/pub/doc/manual/html/pod/perlport.html
.Ve
.PP
To reiterate one important point from the \*(L"WpP\*(R" document:  Not all Perl
programs have to be portable.  If the program or script you're testing
is UNIX-specific, you can (and should) use the \f(CW\*(C`Test::Cmd\*(C'\fR module to
write UNIX-specific tests.
.PP
That having been said, here are some hints that may help keep your tests
portable, if that's a requirement.
.ie n .IP "Use the ""Test::Cmd\-&""here> method for current directory path." 4
.el .IP "Use the \f(CWTest::Cmd\-&\fRhere> method for current directory path." 4
.IX Item "Use the Test::Cmd-&here> method for current directory path."
The normal Perl way to fetch the current working directory is to use the
\&\f(CW\*(C`Cwd::cwd\*(C'\fR method.  Unfortunately, the \f(CW\*(C`Cwd::cwd\*(C'\fR method canonicalizes
the path name it returns, changing the native directory separators into
the forward slashes favored by Perl and \s-1UNIX. \s0 For most Perl scripts,
this makes a great deal of sense and keeps code uncluttered.
.Sp
Passing in a file name that has had its directory separators altered,
however, may confuse the command or script under test, or make it
difficult to compare output from the command or script with an expected
result.  The \f(CW\*(C`Test::Cmd::here\*(C'\fR method returns the absolute path name of
the current working directory, like \f(CW\*(C`Cwd::cwd\*(C'\fR, but does not manipulate
the returned path in any way.
.ie n .IP "Use ""File::Spec"" methods for manipulating path names." 4
.el .IP "Use \f(CWFile::Spec\fR methods for manipulating path names." 4
.IX Item "Use File::Spec methods for manipulating path names."
The File::Spec module provides a system-independent interface for
manipulating path names.  Because the \f(CW\*(C`Test::Cmd\*(C'\fR class is a sub-class
of the File::Spec class, you can use these methods directly as follows:
.Sp
.Vb 3
\&        if (! Test::Cmd\->file_name_is_absolute($prog)) {
\&                my $prog = Test::Cmd\->catfile(Test::Cmd\->here, $prog);
\&        }
.Ve
.Sp
For details about the available methods and their use, see the
documentation for the File::Spec module and its sub-modules, especially
the File::Spec::Unix modules.
.ie n .IP "Use ""Config"" for file-name suffixes, where possible." 4
.el .IP "Use \f(CWConfig\fR for file-name suffixes, where possible." 4
.IX Item "Use Config for file-name suffixes, where possible."
The standard Config module provides values that reflect the file-name
suffixes on the system for which the Perl executable was built.
This provides convenient portability for situations where a file name
may have different extensions on different systems:
.Sp
.Vb 2
\&        $foo_exe = "foo$Config{_exe}";
\&        ok(\-f $foo_exe);
.Ve
.Sp
(Unfortunately, there is no existing \f(CW$Config\fR value that specifies
the suffix for a directly-executable Perl script.)
.IP "Avoid generating executable programs or scripts." 4
.IX Item "Avoid generating executable programs or scripts."
How to make a file or script executable varies widely from system to
system, some systems using file name extensions to indicate executability,
others using a file permission bit.  The differences are complicated to
accommodate in a portable test script.  The easiest way to deal with this
complexity is to avoid it if you can.
.Sp
If your test somehow requires executing a script that you generate
from the test itself, the best way is to generate the script in Perl
and then explicitly feed it to the Perl executable on the local system.
To be maximally portable, use the \f(CW$^X\fR variable instead of hard-coding
\&\*(L"perl\*(R" into the string you execute:
.Sp
.Vb 6
\&        $line = "This is output from the generated perl script.";
\&        $test\->write(\*(Aqscript\*(Aq, <<EOF);
\&        print STDOUT "$line\e\en";
\&        EOF
\&        $output = \`$^X script\`;
\&        ok($output eq "$line\en");
.Ve
.Sp
This completely avoids having to make the \f(CW\*(C`script\*(C'\fR file itself
executable.  (Since you're writing your test in Perl, it's safe to assume
that Perl itself is executable.)
.Sp
If you must generate a directly-executable script, then use the
\&\f(CW$Config{\*(Aqstartperl\*(Aq}\fR variable at the start of the script to generate
the appropriate magic that will execute it as a Perl script:
.Sp
.Vb 10
\&        use Config;
\&        $line = "This is output from the generated perl script.";
\&        $test\->write(\*(Aqscript\*(Aq, <<EOF);
\&        $Config{\*(Aqstartperl\*(Aq};
\&        print STDOUT "$line\e\en";
\&        EOF
\&        chdir($test\->workdir);
\&        chmod(0755, \*(Aqscript\*(Aq);  # POSIX\-SPECIFIC
\&        $output = \`script\`;
\&        ok($output eq "$line\en");
.Ve
.PP
Addtional hints on writing portable tests are welcome.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), Algorithm::DiffOld, File::Find, File::Spec, Test,
Test::Cmd::Common, Test::Harness, Test::More, Test::Simple,
Test::Unit.
.PP
Alternative command-testing modules include:
.PP
Test::Exit, Test::Output, or using Capture::Tiny with one of
the above test modules, for example Test::More.
.PP
A rudimentary page for the \f(CW\*(C`Test::Cmd\*(C'\fR module is available at:
.PP
.Vb 1
\&        http://www.baldmt.com/Test\-Cmd/
.Ve
.PP
The most involved example of using the \f(CW\*(C`Test::Cmd\*(C'\fR package to test
a real-world application is the \f(CW\*(C`cons\-test\*(C'\fR testing suite for the
Cons software construction utility.  The suite uses a sub-class of
Test::Cmd::Common (which in turn is a sub-class of \f(CW\*(C`Test::Cmd\*(C'\fR)
to provide common, application-specific infrastructure across a
large number of end-to-end application tests.  The suite, and other
information about Cons, is available at:
.PP
.Vb 1
\&        http://www.dsmit.com/cons
.Ve
.SH "REPOSITORY"
.IX Header "REPOSITORY"
<https://github.com/neilb/Test\-Cmd>
.SH "AUTHORS"
.IX Header "AUTHORS"
Steven Knight, knight@baldmt.com
.PP
This module is now being maintained by Neil Bowers <neilb@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1999\-2001 Steven Knight.  All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Greg Spencer for the inspiration to create this package and
the initial draft of its implementation as a specific testing package
for the Cons software construction utility.  Information about Cons
is available at:
.PP
.Vb 1
\&        http://www.dsmit.com/cons/
.Ve
.PP
The general idea of managing temporary working directories in this way,
as well as the test reporting of the \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR and \f(CW\*(C`no_result\*(C'\fR
methods, come from the testing framework invented by Peter Miller for
his Aegis project change supervisor.  Aegis is an excellent bit of work
which integrates creation and execution of regression tests into the
software development process.  Information about Aegis is available at:
.PP
.Vb 1
\&        http://www.tip.net.au/~millerp/aegis.html
.Ve
.PP
Thanks to Michael Schwern for all of the thoughtful work he's put into
Perl's standard testing methodology, including the Test::Simple and
Test::More modules, and enhancement and maintenance of the Test
and Test::Harness modules.  Thanks also to Christian Lemburg for
the impressively complete Test::Unit framework of modules.  Ideas
from both have helped keep \f(CW\*(C`Test::Cmd\*(C'\fR flexible enough to be useful in
multiple testing frameworks.
