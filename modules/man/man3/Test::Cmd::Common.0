.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Test::Cmd::Common 3"
.TH Test::Cmd::Common 3 "2015-10-25" "perl v5.24.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Cmd::Common \- module for common Test::Cmd error handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Test::Cmd::Common;
\&
\&  $test = Test::Cmd::Common\->new(string => \*(Aqfunctionality being tested\*(Aq,
\&                        prog => \*(Aqprogram_under_test\*(Aq,
\&                        );
\&
\&  $test\->run(chdir => \*(Aqsubdir\*(Aq, fail => \*(Aq$? != 0\*(Aq,
\&                flags => \*(Aq\-x\*(Aq, targets => \*(Aq.\*(Aq,
\&                stdout => <<_EOF_, stderr => <<_EOF_);
\&  expected standard output
\&  _EOF_
\&  expected error output
\&  _EOF_
\&
\&  $test\->subdir(\*(Aqsubdir\*(Aq, ...);
\&
\&  $test\->read(\e$contents, \*(Aqfile\*(Aq);
\&  $test\->read(\e@lines, \*(Aqfile\*(Aq);
\&
\&  $test\->write(\*(Aqfile\*(Aq, <<_EOF_);
\&  contents of the file
\&  _EOF_
\&
\&  $test\->file_matches();
\&
\&  $test\->must_exist(\*(Aqfile\*(Aq, [\*(Aqsubdir\*(Aq, \*(Aqfile\*(Aq], ...);
\&
\&  $test\->must_not_exist(\*(Aqfile\*(Aq, [\*(Aqsubdir\*(Aq, \*(Aqfile\*(Aq], ...);
\&
\&  $test\->copy(\*(Aqsrc_file\*(Aq, \*(Aqdst_file\*(Aq);
\&
\&  $test\->chmod($mode, \*(Aqfile\*(Aq, ...);
\&
\&  $test\->sleep;
\&  $test\->sleep($seconds);
\&
\&  $test\->touch(\*(Aqfile\*(Aq, ...);
\&
\&  $test\->unlink(\*(Aqfile\*(Aq, ...);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Test::Cmd::Common\*(C'\fR module provides a simple, high-level interface
for writing tests of executable commands and scripts, especially
commands and scripts that interact with the file system.  All methods
throw exceptions and exit on failure.  This makes it unnecessary to add
explicit checks for return values, making the test scripts themselves
simpler to write and easier to read.
.PP
The \f(CW\*(C`Test::Cmd::Common\*(C'\fR class is a subclass of Test::Cmd.  In
essence, \f(CW\*(C`Test::Cmd::Common\*(C'\fR is a wrapper that treats common
Test::Cmd error conditions as exceptions that terminate the test.
You can use \f(CW\*(C`Test::Cmd::Common\*(C'\fR directly, or subclass it for your
program and add additional (or override) methods to tailor it to your
program's specific needs.  Alternatively, \f(CW\*(C`Test::Cmd::Common\*(C'\fR serves as
a useful example of how to define your own Test::Cmd subclass.
.PP
The \f(CW\*(C`Test::Cmd::Common\*(C'\fR module provides the following importable
variables:
.ie n .IP "$_exe" 4
.el .IP "\f(CW$_exe\fR" 4
.IX Item "$_exe"
The executable file suffix.  This value is normally available
as \f(CW$Config{_exe}\fR in Perl version 5.005 and later.  The
\&\f(CW\*(C`Test::Cmd::Common\*(C'\fR module figures it out via other means in earlier
versions.
.ie n .IP "$_o" 4
.el .IP "\f(CW$_o\fR" 4
.IX Item "$_o"
The object file suffix.  This value is normally available
from \f(CW$Config{_o}\fR in Perl version 5.005 and later.  The
\&\f(CW\*(C`Test::Cmd::Common\*(C'\fR module figures it out via other means in earlier
versions.
.ie n .IP "$_a" 4
.el .IP "\f(CW$_a\fR" 4
.IX Item "$_a"
The library file suffix.  This value is normally available
from as \f(CW$Config{_a}\fR in Perl version 5.005 and later.  The
\&\f(CW\*(C`Test::Cmd::Common\*(C'\fR module figures it out via other means in earlier
versions.
.ie n .IP "$_so" 4
.el .IP "\f(CW$_so\fR" 4
.IX Item "$_so"
The shared library file suffix.  This value is normally available
as \f(CW$Config{_so}\fR in Perl version 5.005 and later.  The
\&\f(CW\*(C`Test::Cmd::Common\*(C'\fR module figures it out via other means in earlier
versions.
.ie n .IP "$_is_win32" 4
.el .IP "\f(CW$_is_win32\fR" 4
.IX Item "$_is_win32"
A Boolean value that reflects whether the current platform is a Win32
system.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP """new""" 4
.el .IP "\f(CWnew\fR" 4
.IX Item "new"
Creates a new test environment object.  Any arguments are keyword-value
pairs that are passed through to the construct method for the base
class from which we inherit our methods (that is, the Test::Cmd
class).  In the normal case, this should be the program to be tested and
a description of the functionality being tested:
.Sp
.Vb 2
\&    $test = Test::Cmd::Common\->new(prog => \*(Aqmy_program\*(Aq,
\&                                   string => \*(Aqcool new feature\*(Aq);
.Ve
.Sp
By default, methods that match actual versus expected output (the
\&\f(CW\*(C`run\*(C'\fR, and \f(CW\*(C`file_matches\*(C'\fR methods) use an exact match.  Tests that
require regular expression matches can specify this on initialization of
the test environment:
.Sp
.Vb 3
\&    $test = Test::Cmd::Common\->new(prog => \*(Aqmy_program\*(Aq,
\&                                   string => \*(Aqcool new feature\*(Aq,
\&                                   match_sub => \e&Test::Cmd::diff_regex);
.Ve
.Sp
or by executing the following after initialization of the test
environment:
.Sp
.Vb 1
\&    $test\->match_sub(\e&Test::Cmd::diff_regex);
.Ve
.Sp
Creates a temporary working directory for the test environment and
changes directory to it.
.Sp
Exits \s-1NO RESULT\s0 if the object can not be created, the temporary working
directory can not be created, or the current directory cannot be changed
to the temporary working directory.
.ie n .IP """run""" 4
.el .IP "\f(CWrun\fR" 4
.IX Item "run"
Runs the program under test, checking that the test succeeded.
Arguments are keyword-value pairs that affect the manner in which the
program is executed or the results are evaluated.
.Sp
.Vb 6
\&    chdir => \*(Aqsubdir\*(Aq
\&    fail => \*(Aqfailure condition\*(Aq # default is \*(Aq$? != 0\*(Aq
\&    flags => \*(AqCons flags\*(Aq
\&    stderr => \*(Aqexpected error output\*(Aq
\&    stdout => \*(Aqexpected standard output\*(Aq
\&    targets => \*(Aqtargets to build\*(Aq
.Ve
.Sp
The test fails if:
.Sp
.Vb 3
\&  \-\-  The specified failure condition is met.  The default failure
\&      condition is \*(Aq$? != 0\*(Aq, i.e. the program exits unsuccesfully.
\&      A not\-uncommon alternative is:
\&
\&          $test\->run(fail => \*(Aq$? == 0\*(Aq);        # expect failure
\&
\&      when testing how the program handles errors.
\&
\&  \-\-  Actual standard output does not match expected standard output
\&      (if any).  The expected standard output is an array of lines
\&      or a scalar which will be split on newlines.
\&
\&  \-\-  Actual error output does not match expected error output (if
\&      any).  The expected error output is an array of lines or a
\&      scalar which will be split on newlines.
\&
\&      This method will test for NO error output by default if no
\&      expected error output is specified (unlike standard output).
\&      The error output test may be explicitly suppressed by
\&      specifying undef as the "expected" error output:
\&
\&          $test\->run(stderr => undef);
.Ve
.Sp
By default, this method performs an exact match of actual vs. expected
standard output or error output:
.Sp
.Vb 6
\&    $test\->run(stdout => <<_EOF_, stderr => _EOF_);
\&    An expected STDOUT line, which must be matched exactly.
\&    _EOF_
\&    One or more expected STDERR lines,
\&    which must be matched exactly.
\&    _EOF_
.Ve
.Sp
Tests that require regular expression matches should be executed using a
test environment that calls the \f(CW\*(C`match_sub\*(C'\fR method as follows:
.Sp
.Vb 1
\&    $test\->match_sub(\e&Test::Cmd::diff_regex);
\&
\&    $test\->run(stdout => <<_EOF_, stderr => _EOF_);
\&    An expected (STDOUT|standard output) line\e.
\&    _EOF_
\&    One or more expected (STDERR|error output) lines,
\&    which may contain (regexes|regular expressions)\e.
\&    _EOF_
.Ve
.ie n .IP """subdir""" 4
.el .IP "\f(CWsubdir\fR" 4
.IX Item "subdir"
Creates one or more subdirectories in the temporary working directory.
Exits \s-1NO RESULT\s0 if the number of subdirectories actually created does
not match the number expected.  For compatibility with its superclass
method, returns the number of subdirectories actually created.
.ie n .IP """read""" 4
.el .IP "\f(CWread\fR" 4
.IX Item "read"
Reads the contents of a file, depositing the contents in the destination
referred to by the first argument (a scalar or array reference).  If the
file name is not an absolute path name, it is relative to the temporary
working directory.  Exits \s-1NO RESULT\s0 if the file could not be read for
any reason.  For compatibility with its superclass method, returns \s-1TRUE\s0
on success.
.ie n .IP """write""" 4
.el .IP "\f(CWwrite\fR" 4
.IX Item "write"
Writes a file with the specified contents.  If the file name is not an
absolute path name, it is relative to the temporary working directory.
Exits \s-1NO RESULT\s0 if there were any errors writing the file.
For compatibility with its superclass method, returns \s-1TRUE\s0 on success.
.Sp
.Vb 3
\&    $test\->write(\*(Aqfile\*(Aq, <<_EOF_);
\&    contents of the file
\&    _EOF_
.Ve
.ie n .IP """file_matches""" 4
.el .IP "\f(CWfile_matches\fR" 4
.IX Item "file_matches"
Matches the contents of the specified file (first argument) against the
expected contents.  The expected contents are an array of lines or a
scalar which will be split on newlines.  By default, each expected line
must match exactly its corresponding line in the file:
.Sp
.Vb 4
\&    $test\->file_matches(\*(Aqfile\*(Aq, <<_EOF_);
\&    Line #1.
\&    Line #2.
\&    _EOF_
.Ve
.Sp
Tests that require regular expression matches should be executed using a
test environment that calls the \f(CW\*(C`match_sub\*(C'\fR method as follows:
.Sp
.Vb 1
\&    $test\->match_sub(\e&Test::Cmd::diff_regex);
\&
\&    $test\->file_matches(\*(Aqfile\*(Aq, <<_EOF_);
\&    The (1st|first) line\e.
\&    The (2nd|second) line\e.
\&    _EOF_
.Ve
.ie n .IP """must_exist""" 4
.el .IP "\f(CWmust_exist\fR" 4
.IX Item "must_exist"
Ensures that the specified files must exist.  Files may be specified as
an array reference of directory components, in which case the pathname
will be constructed by concatenating them.  Exits \s-1FAILED\s0 if any of the
files does not exist.
.ie n .IP """must_not_exist""" 4
.el .IP "\f(CWmust_not_exist\fR" 4
.IX Item "must_not_exist"
Ensures that the specified files must not exist.  Files may be specified
as an array reference of directory components, in which case the pathname
will be constructed by concatenating them.  Exits \s-1FAILED\s0 if any of the
files exists.
.ie n .IP """copy""" 4
.el .IP "\f(CWcopy\fR" 4
.IX Item "copy"
Copies a file from the source (first argument) to the destination
(second argument).  Exits \s-1NO RESULT\s0 if the file could not be copied
for any reason.
.ie n .IP """chmod""" 4
.el .IP "\f(CWchmod\fR" 4
.IX Item "chmod"
Changes the permissions of a list of files to the specified mode (first
argument).  Exits \s-1NO RESULT\s0 if any file could not be changed for any
reason.
.ie n .IP """sleep""" 4
.el .IP "\f(CWsleep\fR" 4
.IX Item "sleep"
Sleeps at least the specified number of seconds.  If no number is
specified, sleeps at least a minimum number of seconds necessary to
advance file time stamps on the current system.  Sleeping more seconds
is all right.  Exits \s-1NO RESULT\s0 if the time slept was less than specified.
.ie n .IP """touch""" 4
.el .IP "\f(CWtouch\fR" 4
.IX Item "touch"
Updates the access and modification times of the specified files.
Exits \s-1NO RESULT\s0 if any file could not be modified for any reason.
.ie n .IP """unlink""" 4
.el .IP "\f(CWunlink\fR" 4
.IX Item "unlink"
Removes the specified files.  Exits \s-1NO RESULT\s0 if any file could not be
removed for any reason.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The \f(CW\*(C`Test::Cmd::Common\*(C'\fR module also uses the
\&\f(CW\*(C`PRESERVE\*(C'\fR,
\&\f(CW\*(C`PRESERVE_FAIL\*(C'\fR,
\&\f(CW\*(C`PRESERVE_NO_RESULT\*(C'\fR,
and \f(CW\*(C`PRESERVE_PASS\*(C'\fR
environment variables from the Test::Cmd module.
See the Test::Cmd documentation for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), Test::Cmd.
.PP
The most involved example of using the \f(CW\*(C`Test::Cmd::Common\*(C'\fR module
to test a real-world application is the \f(CW\*(C`cons\-test\*(C'\fR testing suite
for the Cons software construction utility.  The suite sub-classes
\&\f(CW\*(C`Test::Cmd::Common\*(C'\fR to provide common, application-specific
infrastructure across a large number of end-to-end application tests.
The suite, and other information about Cons, is available at:
.PP
.Vb 1
\&        http://www.dsmit.com/cons
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Steven Knight, knight@baldmt.com
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Johan Holmberg for asking the question that led to the
creation of this package.
.PP
The general idea of testing commands in this way, as well as the test
reporting of the \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`fail\*(C'\fR and \f(CW\*(C`no_result\*(C'\fR methods, come from
the testing framework invented by Peter Miller for his Aegis project
change supervisor.  Aegis is an excellent bit of work which integrates
creation and execution of regression tests into the software development
process.  Information about Aegis is available at:
.PP
.Vb 1
\&        http://www.tip.net.au/~millerp/aegis.html
.Ve
