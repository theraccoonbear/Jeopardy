.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "App::bmkpasswd 3"
.TH App::bmkpasswd 3 "2016-07-27" "perl v5.24.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::bmkpasswd \- bcrypt\-capable mkpasswd(1) and exported bcrypt interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  ## From Perl:
\&
\&  use App::bmkpasswd \-all;
\&  my $bcrypted = mkpasswd($passwd);
\&  say \*(Aqmatched\*(Aq if passwdcmp($passwd, $bcrypted);
\&
\&  my $stronger = mkpasswd($passwd, \*(Aqbcrypt\*(Aq, 12);
\&
\&  ## From a shell:
\&
\&  bmkpasswd \-\-help
\&  
\&  # Generate bcrypted passwords:
\&  bmkpasswd
\&
\&  # Defaults to work cost factor \*(Aq08\*(Aq:
\&  bmkpasswd \-\-workcost=\*(Aq06\*(Aq
\&
\&  # SHA requires Crypt::Passwd::XS or a recent libc:
\&  bmkpasswd \-\-method=\*(Aqsha512\*(Aq
\&  
\&  # Compare a hash:
\&  bmkpasswd \-\-check=HASH
\&
\&  # Check hash generation times:
\&  bmkpasswd \-\-benchmark
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBApp::bmkpasswd\fR is a bcrypt-enabled \f(CW\*(C`mkpasswd\*(C'\fR implementation.
.PP
Helper functions are also exported for use in other applications; see
\&\*(L"\s-1EXPORTED\*(R"\s0 \*(-- however Crypt::Bcrypt::Easy (from this distribution)
provides an easier bcrypt-specific programmatic interface for Perl
programmers.
.PP
See \f(CW\*(C`bmkpasswd \-\-help\*(C'\fR for command-line usage information.
.PP
Bcrypt leverages a work-cost factor allowing hash generation
to become configurably slower as computers get faster, thereby
impeding brute-force hash generation attempts.
See <http://codahale.com/how\-to\-safely\-store\-a\-password/> for more
on why you ought to be using bcrypt or similar \*(L"adaptive\*(R" techniques.
.PP
\&\fB\s-1SHA\-256\s0\fR and \fB\s-1SHA\-512\s0\fR are supported if available. \s-1SHA\s0 support requires
either Crypt::Passwd::XS or a system \fIcrypt()\fR that can handle \s-1SHA \s0(such as
glibc\-2.7+ or modern FreeBSD builds).
.PP
This module uses Crypt::Eksblowfish::Bcrypt as a back-end.
.PP
Uses Bytes::Random::Secure::Tiny to generate random salts. Strongly-random salts
can also be enabled; see \*(L"mkpasswd\*(R".
.SH "EXPORTED"
.IX Header "EXPORTED"
Crypt::Bcrypt::Easy provides an easier programmatic interface, but only
generates bcrypt (although it can validate any supported type).  If you would
like to create crypted passwords using other methods, you can use the exported
\&\fBmkpasswd\fR and \fBpasswdcmp\fR functions:
.PP
.Vb 4
\&  # Import selectively:
\&  use App::bmkpasswd \*(Aqmkpasswd\*(Aq, \*(Aqpasswdcmp\*(Aq;
\&  # Or import all functions:
\&  use App::bmkpasswd \-all;
.Ve
.PP
This module uses Exporter::Tiny to export functions. This provides for
flexible import options. See the Exporter::Tiny docs for details.
.SS "passwdcmp"
.IX Subsection "passwdcmp"
Compare a password against a hash.
.PP
.Vb 5
\&  if ( passwdcmp($plaintext => $crypted) ) {
\&    ## Successful match
\&  } else {
\&    ## Failed match
\&  }
.Ve
.PP
\&\fBpasswdcmp\fR will return the hash if it is a match; otherwise, \f(CW\*(C`undef\*(C'\fR
is returned. (This is an \s-1API\s0 change in \f(CW\*(C`v2.7.1\*(C'\fR; prior versions return
an empty list on failure.)
.PP
As of \f(CW\*(C`v2.10\*(C'\fR, a constant time comparison function is used to compare hashes.
.SS "mkpasswd"
.IX Subsection "mkpasswd"
.Vb 4
\&  my $crypted = mkpasswd($passwd);
\&  my $crypted = mkpasswd($passwd, $type);
\&  my $crypted = mkpasswd($passwd, \*(Aqbcrypt\*(Aq, $cost);
\&  my $crypted = mkpasswd($passwd, $type, $cost, $strongsalt);
\&
\&  my $crypted = mkpasswd( $passwd => 
\&    +{
\&      type    => $type,
\&      cost    => $cost,
\&      strong  => $strongsalt,
\&      saltgen => $saltgenerator,
\&    }
\&  );
.Ve
.PP
Generate hashed passwords.
.PP
By default, generates a bcrypted passwd with work-cost 08:
.PP
.Vb 1
\&  $bcrypted = mkpasswd($passwd);
.Ve
.PP
A different work-cost can be specified for bcrypt passwds:
.PP
.Vb 1
\&  $bcrypted = mkpasswd($passwd, \*(Aqbcrypt\*(Aq, \*(Aq10\*(Aq);
.Ve
.PP
\&\s-1SHA\-256\s0 and \s-1SHA\-512\s0 are supported, in which case the work-cost value is ignored:
.PP
.Vb 2
\&  $crypted = mkpasswd($passwd, \*(Aqsha256\*(Aq);
\&  $crypted = mkpasswd($passwd, \*(Aqsha512\*(Aq);
.Ve
.PP
If a fourth boolean-true argument is specified, a strongly-random salt is
generated. This requires spare entropy, and will block if entropy-starved:
.PP
.Vb 2
\&  $crypted = mkpasswd($passwd, \*(Aqbcrypt\*(Aq, \*(Aq08\*(Aq, \*(Aqstrong\*(Aq);
\&  $crypted = mkpasswd($passwd, \*(Aqsha512\*(Aq, 0, \*(Aqstrong\*(Aq);
.Ve
.PP
Options can be passed as a \s-1HASH,\s0 instead. This also lets you pass in a salt
generator coderef:
.PP
.Vb 7
\&  $crypted = mkpasswd( $passwd => +{
\&      type => \*(Aqbcrypt\*(Aq,
\&      cost => \*(Aq10\*(Aq,
\&      strong  => 0,
\&      saltgen => $saltgenerator,
\&    }
\&  );
.Ve
.PP
The salt generator is passed the type (one of: \f(CW\*(C`bcrypt\*(C'\fR, \f(CW\*(C`sha\*(C'\fR, \f(CW\*(C`md5\*(C'\fR) and
the value of the \fBstrong\fR option (default false).
.PP
.Vb 10
\&  my $saltgenerator = sub {
\&    my ($type, $strongsalt) = @_;
\&    if ($type eq \*(Aqbcrypt\*(Aq) {
\&      # ...
\&    } elsif ($type eq \*(Aqsha\*(Aq) {
\&      # ...
\&    } else {
\&      die "Don\*(Aqt know how to create a salt for type \*(Aq$type\*(Aq!"
\&    }
\&  };
.Ve
.PP
Most people want random salts, in which case the default salt generator
should be fine.
.PP
See \*(L"mkpasswd_forked\*(R" if your application loads this module before forking
or creating threads that generate passwords.
.SS "mkpasswd_available"
.IX Subsection "mkpasswd_available"
.Vb 1
\&  my @available = mkpasswd_available;
\&
\&  if ( mkpasswd_available(\*(Aqsha512\*(Aq) ) { ... }
.Ve
.PP
Given no arguments, returns the list of available hash types.
.PP
Given a type (see \*(L"mkpasswd\*(R"), returns boolean true if the method is available. ('bcrypt' is
always available.)
.SS "mkpasswd_forked"
.IX Subsection "mkpasswd_forked"
.Vb 2
\&  # After a fork / new thread is created:
\&  mkpasswd_forked;
.Ve
.PP
To retain secure salts after forking the process or creating a new thread, 
it's advisable to either only load this module after creating the new process
or call \fBmkpasswd_forked\fR in the new process to reset the random seeds used
by salt generators.
.PP
Added in \f(CW\*(C`v2.6.1\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jon Portnoy <jon@portnoy.me>
