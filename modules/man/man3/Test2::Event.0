.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Test2::Event 3"
.TH Test2::Event 3 "2017-05-02" "perl v5.24.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test2::Event \- Base class for events
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Base class for all event objects that get passed through
Test2.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package Test2::Event::MyEvent;
\&    use strict;
\&    use warnings;
\&
\&    # This will make our class an event subclass (required)
\&    use base \*(AqTest2::Event\*(Aq;
\&
\&    # Add some accessors (optional)
\&    # You are not obligated to use HashBase, you can use any object tool you
\&    # want, or roll your own accessors.
\&    use Test2::Util::HashBase qw/foo bar baz/;
\&
\&    # Chance to initialize some defaults
\&    sub init {
\&        my $self = shift;
\&        # no other args in @_
\&
\&        $self\->set_foo(\*(Aqxxx\*(Aq) unless defined $self\->foo;
\&
\&        ...
\&    }
\&
\&    1;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$trace = $e\->trace" 4
.el .IP "\f(CW$trace\fR = \f(CW$e\fR\->trace" 4
.IX Item "$trace = $e->trace"
Get a snapshot of the Test2::Util::Trace as it was when this event was
generated
.ie n .IP "$bool = $e\->causes_fail" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->causes_fail" 4
.IX Item "$bool = $e->causes_fail"
Returns true if this event should result in a test failure. In general this
should be false.
.ie n .IP "$bool = $e\->increments_count" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->increments_count" 4
.IX Item "$bool = $e->increments_count"
Should be true if this event should result in a test count increment.
.ie n .IP "$e\->callback($hub)" 4
.el .IP "\f(CW$e\fR\->callback($hub)" 4
.IX Item "$e->callback($hub)"
If your event needs to have extra effects on the Test2::Hub you can override
this method.
.Sp
This is called \fB\s-1BEFORE\s0\fR your event is passed to the formatter.
.ie n .IP "$num = $e\->nested" 4
.el .IP "\f(CW$num\fR = \f(CW$e\fR\->nested" 4
.IX Item "$num = $e->nested"
If this event is nested inside of other events, this should be the depth of
nesting. (This is mainly for subtests)
.ie n .IP "$bool = $e\->global" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->global" 4
.IX Item "$bool = $e->global"
Set this to true if your event is global, that is \s-1ALL\s0 threads and processes
should see it no matter when or where it is generated. This is not a common
thing to want, it is used by bail-out and skip_all to end testing.
.ie n .IP "$code = $e\->terminate" 4
.el .IP "\f(CW$code\fR = \f(CW$e\fR\->terminate" 4
.IX Item "$code = $e->terminate"
This is called \fB\s-1AFTER\s0\fR your event has been passed to the formatter. This
should normally return undef, only change this if your event should cause the
test to exit immediately.
.Sp
If you want this event to cause the test to exit you should return the exit
code here. Exit code of 0 means exit success, any other integer means exit with
failure.
.Sp
This is used by Test2::Event::Plan to exit 0 when the plan is
\&'skip_all'. This is also used by Test2::Event:Bail to force the test
to exit with a failure.
.Sp
This is called after the event has been sent to the formatter in order to
ensure the event is seen and understood.
.ie n .IP "$msg = $e\->summary" 4
.el .IP "\f(CW$msg\fR = \f(CW$e\fR\->summary" 4
.IX Item "$msg = $e->summary"
This is intended to be a human readable summary of the event. This should
ideally only be one line long, but you can use multiple lines if necessary. This
is intended for human consumption. You do not need to make it easy for machines
to understand.
.Sp
The default is to simply return the event package name.
.ie n .IP "($count, $directive, $reason) = $e\->\fIsets_plan()\fR" 4
.el .IP "($count, \f(CW$directive\fR, \f(CW$reason\fR) = \f(CW$e\fR\->\fIsets_plan()\fR" 4
.IX Item "($count, $directive, $reason) = $e->sets_plan()"
Check if this event sets the testing plan. It will return an empty list if it
does not. If it does set the plan it will return a list of 1 to 3 items in
order: Expected Test Count, Test Directive, Reason for directive.
.ie n .IP "$bool = $e\->diagnostics" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->diagnostics" 4
.IX Item "$bool = $e->diagnostics"
True if the event contains diagnostics info. This is useful because a
non-verbose harness may choose to hide events that are not in this category.
Some formatters may choose to send these to \s-1STDERR\s0 instead of \s-1STDOUT\s0 to ensure
they are seen.
.ie n .IP "$bool = $e\->no_display" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->no_display" 4
.IX Item "$bool = $e->no_display"
False by default. This will return true on events that should not be displayed
by formatters.
.ie n .IP "$id = $e\->in_subtest" 4
.el .IP "\f(CW$id\fR = \f(CW$e\fR\->in_subtest" 4
.IX Item "$id = $e->in_subtest"
If the event is inside a subtest this should have the subtest \s-1ID.\s0
.ie n .IP "$id = $e\->subtest_id" 4
.el .IP "\f(CW$id\fR = \f(CW$e\fR\->subtest_id" 4
.IX Item "$id = $e->subtest_id"
If the event is a final subtest event, this should contain the subtest \s-1ID.\s0
.ie n .IP "$bool_or_undef = $e\->related($e2)" 4
.el .IP "\f(CW$bool_or_undef\fR = \f(CW$e\fR\->related($e2)" 4
.IX Item "$bool_or_undef = $e->related($e2)"
Check if 2 events are related. In this case related means their traces share a
signature meaning they were created with the same context (or at the very least
by contexts which share an id, which is the same thing unless someone is doing
something very bad).
.Sp
This can be used to reliably link multiple events created by the same tool. For
instance a failing test like \f(CW\*(C`ok(0, "fail"\*(C'\fR will generate 2 events, one being
a Test2::Event::Ok, the other being a Test2::Event::Diag, both of these
events are related having been created under the same context and by the same
initial tool (though multiple tools may have been nested under the initial
one).
.Sp
This will return \f(CW\*(C`undef\*(C'\fR if the relationship cannot be checked, which happens
if either event has an incomplete or missing trace. This will return \f(CW0\fR if
the traces are complete, but do not match. \f(CW1\fR will be returned if there is a
match.
.ie n .IP "$hashref = $e\->\s-1TO_JSON\s0" 4
.el .IP "\f(CW$hashref\fR = \f(CW$e\fR\->\s-1TO_JSON\s0" 4
.IX Item "$hashref = $e->TO_JSON"
This returns a hashref suitable for passing to the \f(CW\*(C`Test2::Event\->from_json\*(C'\fR constructor. It is intended for use with the \s-1JSON\s0 family of modules,
which will look for a \f(CW\*(C`TO_JSON\*(C'\fR method when \f(CW\*(C`convert_blessed\*(C'\fR is true.
.ie n .IP "$e = Test2::Event\->from_json(%$hashref)" 4
.el .IP "\f(CW$e\fR = Test2::Event\->from_json(%$hashref)" 4
.IX Item "$e = Test2::Event->from_json(%$hashref)"
Given the hash of data returned by \f(CW\*(C`$e\->TO_JSON\*(C'\fR, this method returns a
new event object of the appropriate subclass.
.SH "THIRD PARTY META-DATA"
.IX Header "THIRD PARTY META-DATA"
This object consumes Test2::Util::ExternalMeta which provides a consistent
way for you to attach meta-data to instances of this class. This is useful for
tools, plugins, and other extensions.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test2 can be found at
\&\fIhttp://github.com/Test\-More/test\-more/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2017 Chad Granum <exodist@cpan.org>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
